use std::{
    collections::{HashMap, VecDeque},
    fmt::Debug,
    ops::Deref,
};

use crate::{
    error::Error,
    sir::SIRBranchEdge,
    traits::{
        ExtInstructionAccess, GenericInstruction, GenericOpcode, GenericSIRNode, InstructionAccess,
        Oparg, SIROwned, SimpleInstructionAccess,
    },
};

#[cfg(feature = "dot")]
use petgraph::{
    dot::{Config, Dot},
    graph::NodeIndex,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BlockIndex {
    /// Index of the block in the `blocks` list of the CFG
    Index(usize),
    /// For jumps with invalid jump targets (the value is the invalid jump index)
    InvalidIndex(usize),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BlockIndexInfo<O>
where
    O: GenericOpcode,
{
    Edge(BranchEdge<O>),
    /// For blocks that fallthrough with no opcode (cannot be generated by Python, used by internal algorithms)
    Fallthrough(BlockIndex),
    /// For blocks without a target
    NoIndex,
}

impl<O> BlockIndexInfo<O>
where
    O: GenericOpcode,
{
    pub fn into_sir<SIRNode>(
        &self,
        statements: Option<Vec<crate::sir::SIRStatement<SIRNode>>>,
    ) -> crate::sir::SIRBlockIndexInfo<SIRNode>
    where
        SIRNode: GenericSIRNode<Opcode = O>,
        crate::sir::SIR<SIRNode>: SIROwned<SIRNode>,
    {
        match &self {
            BlockIndexInfo::Edge(edge) => crate::sir::SIRBlockIndexInfo::Edge(SIRBranchEdge {
                opcode: edge.opcode.clone(),
                statements: statements.map(|v| crate::sir::SIR::new(v)),
                block_index: edge.block_index.clone(),
            }),
            BlockIndexInfo::Fallthrough(block_index) => {
                crate::sir::SIRBlockIndexInfo::Fallthrough(block_index.clone())
            }
            BlockIndexInfo::NoIndex => crate::sir::SIRBlockIndexInfo::NoIndex,
        }
    }
}

impl<O> BlockIndexInfo<O>
where
    O: GenericOpcode,
{
    pub fn get_block_index(&self) -> Option<&BlockIndex> {
        match self {
            BlockIndexInfo::Edge(BranchEdge { block_index, .. }) => Some(block_index),
            BlockIndexInfo::Fallthrough(block_index) => Some(block_index),
            BlockIndexInfo::NoIndex => None,
        }
    }
}

/// Used to represent the opcode that was used for this branch and the block index it's jumping to.
/// We do this so the value of the branch instruction cannot represent a wrong index.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BranchEdge<O>
where
    O: GenericOpcode,
{
    pub opcode: O,
    pub block_index: BlockIndex,
}

#[derive(Debug, PartialEq, Eq)]
/// Represents a block in the control flow graph
pub struct Block<I>
where
    I: GenericInstruction,
{
    pub instructions: Vec<I>,
    /// Index to block for conditional jump
    pub branch_block: BlockIndexInfo<I::Opcode>,
    /// Index to default block (unconditional)
    pub default_block: BlockIndexInfo<I::Opcode>,
}

impl<T> Block<T>
where
    T: GenericInstruction,
{
    pub fn is_terminating(&self) -> bool {
        matches!(self.default_block, BlockIndexInfo::NoIndex)
    }

    /// Whether the block has a conditional jump or not
    pub fn is_conditional(&self) -> bool {
        matches!(
            self.branch_block,
            BlockIndexInfo::Edge(BranchEdge {
                block_index: BlockIndex::Index(_),
                ..
            })
        )
    }
}

#[derive(Debug, PartialEq)]
pub struct ControlFlowGraph<I>
where
    I: GenericInstruction,
{
    pub blocks: Vec<Block<I>>,
    pub start_index: BlockIndexInfo<I::Opcode>,
}

#[cfg(feature = "dot")]
impl<I> ControlFlowGraph<I>
where
    I: GenericInstruction,
{
    pub fn make_dot_graph(&self) -> String {
        let mut graph = petgraph::Graph::<String, String>::new();

        Self::add_block(
            &mut graph,
            &self.blocks,
            self.start_index.get_block_index(),
            &mut HashMap::new(),
        );

        format!(
            "{:#?}",
            Dot::with_attr_getters(
                &graph,
                &[Config::NodeNoLabel],
                &|_, e| {
                    let color = if e.weight() != "fallthrough" {
                        "green"
                    } else {
                        "red"
                    };

                    format!("color = {}", color)
                },
                &|_, (_, s)| format!(r#"label = "{}""#, s),
            )
        )
    }

    fn add_block<'a>(
        graph: &mut petgraph::Graph<String, String>,
        blocks: &'a [Block<I>],
        block_index: Option<&'a BlockIndex>,
        block_map: &mut HashMap<Option<&'a BlockIndex>, NodeIndex>,
    ) -> Option<NodeIndex> {
        let block = match block_index {
            Some(BlockIndex::Index(index)) => blocks.get(*index).unwrap(),
            _ => return None,
        };

        let mut lines = block
            .instructions
            .iter()
            .map(|i| format!("{:#?} {:#?}", i.get_opcode(), i.get_raw_value()))
            .collect::<Vec<_>>();

        if let BlockIndexInfo::Edge(BranchEdge { opcode, .. }) = &block.branch_block {
            lines.push(format!("{:#?}", opcode.clone()));
        }

        let text = lines.join("\n");

        let index = if block_map.contains_key(&block_index) {
            block_map[&block_index]
        } else {
            let index = graph.add_node(text);
            block_map.insert(block_index.clone(), index);

            index
        };

        let (branch_index, opcode) = match &block.branch_block {
            BlockIndexInfo::Edge(BranchEdge {
                block_index: branch_index,
                opcode,
            }) => (Some(branch_index), Some(opcode.clone())),
            _ => (None, None),
        };

        let branch_index = if block_map.contains_key(&branch_index) {
            Some(block_map[&branch_index])
        } else {
            let index = Self::add_block(graph, blocks, branch_index, block_map);

            let index = if let Some(index) = index {
                block_map.insert(branch_index.clone(), index);
                Some(index)
            } else {
                match branch_index {
                    Some(BlockIndex::InvalidIndex(invalid_index)) => {
                        Some(graph.add_node(format!("invalid jump to index {}", invalid_index)))
                    }
                    Some(BlockIndex::Index(_)) => unreachable!(),
                    None => None,
                }
            };

            index
        };

        let default_index = if block_map.contains_key(&block.default_block.get_block_index()) {
            Some(block_map[&block.default_block.get_block_index()])
        } else {
            let index = Self::add_block(
                graph,
                blocks,
                block.default_block.get_block_index(),
                block_map,
            );

            let index = if let Some(index) = index {
                block_map.insert(block.default_block.get_block_index(), index);
                Some(index)
            } else {
                match block.default_block.get_block_index() {
                    Some(BlockIndex::InvalidIndex(invalid_index)) => {
                        Some(graph.add_node(format!("invalid jump to index {}", invalid_index)))
                    }
                    Some(BlockIndex::Index(_)) => unreachable!(),
                    None => None,
                }
            };

            index
        };

        if let Some(to_index) = branch_index {
            let text = format!("{:#?}", opcode.unwrap());
            graph.add_edge(index, to_index, text);
        }

        if let Some(to_index) = default_index {
            graph.add_edge(index, to_index, "fallthrough".to_string());
        }

        Some(index)
    }
}

impl<I, T> SimpleInstructionAccess<I> for T where
    T: Deref<Target = [I]> + AsRef<[I]> + InstructionAccess<u8, I>
{
}

/// This "fixes" a unique pattern:
///
/// LOAD_CONST 0
/// POP_JUMP_FORWARD_IF_TRUE 1
/// EXTENDED_ARG
/// STORE_NAME 0
///
/// We will convert this to
///
/// LOAD_CONST 0
/// POP_JUMP_FORWARD_IF_TRUE 3
/// EXTENDED_ARG
/// STORE_NAME 0
/// JUMP_FORWARD 1
/// STORE_NAME 0
///
/// `blocks_to_fix` contains a list of blocks indexes that jump over an EXTENDED_ARG
/// TODO: This fix doesn't work if the target instruction is another jump
fn fix_extended_args<I>(cfg: &mut ControlFlowGraph<I>, blocks_to_fix: &[BlockIndex])
where
    I: GenericInstruction,
{
    for block_to_fix in blocks_to_fix {
        match block_to_fix {
            BlockIndex::Index(index) => {
                let default_block_index = match cfg.blocks[*index].default_block {
                    BlockIndexInfo::Edge(BranchEdge {
                        block_index: BlockIndex::Index(default_index),
                        ..
                    }) => default_index,
                    _ => unreachable!(),
                };

                let branch_block_index = match cfg.blocks[*index].branch_block {
                    BlockIndexInfo::Edge(BranchEdge {
                        block_index: BlockIndex::Index(branch_index),
                        ..
                    }) => branch_index,
                    _ => unreachable!(),
                };

                // The instruction that the EXTENDED_ARG should be applied to is at the start of this one
                let mut instructions = cfg.blocks[branch_block_index].instructions.clone();

                // If there are multiple extended args, this should indicate that
                let instructions_to_copy = instructions
                    .iter()
                    .take_while(|i| i.is_extended_arg())
                    .count()
                    // The instruction itself
                    + 1;

                // Remove rest of instructions in the branch block
                cfg.blocks
                    .get_mut(branch_block_index)
                    .expect("index is valid here")
                    .instructions = instructions
                    .iter()
                    .take(instructions_to_copy)
                    .cloned()
                    .collect();

                // Copy the instruction(s) behind the EXTENDED_ARG
                cfg.blocks
                    .get_mut(default_block_index)
                    .expect("index is valid here")
                    .instructions
                    .extend_from_slice(
                        &instructions
                            .iter()
                            .take(instructions_to_copy)
                            .cloned()
                            .collect::<Vec<_>>(),
                    );

                // Remove first instruction(s) in the branch block that we will copy into the new branch block
                let instructions = if !instructions.is_empty() {
                    // Can be empty if we're jumping to another branch instruction (which is not included in the basic block)
                    // This does not fix it yet, but it's a WIP
                    instructions.split_off(instructions_to_copy)
                } else {
                    instructions
                };

                // Create new block that has the remaining instructions of the branch block
                cfg.blocks.push(Block {
                    instructions,
                    branch_block: cfg.blocks[branch_block_index].branch_block.clone(),
                    default_block: cfg.blocks[branch_block_index].default_block.clone(),
                });

                let new_block_index = cfg.blocks.len() - 1;

                cfg.blocks
                    .get_mut(branch_block_index)
                    .expect("index is valid here")
                    .default_block =
                    BlockIndexInfo::Fallthrough(BlockIndex::Index(new_block_index));

                cfg.blocks
                    .get_mut(branch_block_index)
                    .expect("index is valid here")
                    .branch_block = BlockIndexInfo::NoIndex;

                cfg.blocks
                    .get_mut(default_block_index)
                    .expect("index is valid here")
                    .default_block =
                    BlockIndexInfo::Fallthrough(BlockIndex::Index(new_block_index));
                // TODO: Add correct info

                // Should never happen but just in case we will add a NOP.
                if cfg.blocks[new_block_index].instructions.is_empty() {
                    cfg.blocks
                        .get_mut(new_block_index)
                        .expect("index is valid here")
                        .instructions
                        .push(I::get_nop());
                }
            }
            _ => unreachable!(),
        }
    }
}

pub fn create_cfg<OpargType, I>(instructions: Vec<I>) -> ControlFlowGraph<I>
where
    OpargType: Oparg,
    I: GenericInstruction,
    Vec<I>: InstructionAccess<OpargType, I>,
{
    // Used for keeping track of finished blocks
    let mut blocks: Vec<Block<I>> = vec![];

    // Maps instruction index to block index
    let mut block_map: HashMap<usize, BlockIndex> = HashMap::new();

    let jump_map = instructions.get_jump_map();

    // Keeps indexes of instructions that start new blocks and still need to be processed.
    let mut block_queue: VecDeque<usize> = VecDeque::new();
    block_queue.push_front(0);

    // A list of block indexes that will be used to fix a unique EXTENDED_ARG pattern. See `fix_extended_args`.
    let mut block_indexes_to_fix = vec![];

    let mut curr_block_index = 0;

    while !block_queue.is_empty() {
        let mut index = block_queue.pop_back().expect("queue is not empty");

        let mut curr_block = vec![];

        let start_index = index;

        enum ExitReason {
            BlockExists,
            IsJumpTarget,
            DoesJump,
            StopsExecution,
        }

        let exit_reason = loop {
            if block_map.contains_key(&index) {
                if !curr_block.is_empty() {
                    blocks.push(Block {
                        instructions: curr_block,
                        branch_block: BlockIndexInfo::NoIndex,
                        default_block: BlockIndexInfo::Fallthrough(block_map[&index].clone()),
                    });
                }

                break ExitReason::BlockExists;
            } else if jump_map.values().any(|e| *e == (index as u32)) && !curr_block.is_empty() {
                // If this is a jump target, place it in a new block (used to support backwards jumps)

                blocks.push(Block {
                    instructions: curr_block,
                    branch_block: BlockIndexInfo::NoIndex,
                    // The fallthrough block will be processed after the queue is empty
                    default_block: BlockIndexInfo::Fallthrough(BlockIndex::Index(
                        curr_block_index + 1 + block_queue.len(),
                    )),
                });

                block_queue.push_front(index);

                break ExitReason::IsJumpTarget;
            }

            let instruction = instructions[index].clone();

            if instruction.is_jump() {
                let next_instruction =
                    if index + 1 < instructions.len() && instruction.is_conditional_jump() {
                        Some(index + 1)
                    } else {
                        None
                    };

                let jump_instruction = if let Some(jump_index) = jump_map.get(&(index as u32)) {
                    if instruction.is_conditional_jump()
                        && let Some(instruction) = instructions.get(*jump_index as usize - 1)
                        && instruction.is_extended_arg()
                    {
                        block_indexes_to_fix.push(BlockIndex::Index(curr_block_index));
                    }
                    Some(*jump_index)
                } else {
                    None
                };

                // Remove extended args from the end of curr_block (they're already calculated in the jump target)
                while let Some(last) = curr_block.last() {
                    if last.is_extended_arg() {
                        curr_block.pop();
                    } else {
                        break;
                    }
                }

                blocks.push(Block {
                    instructions: curr_block,
                    branch_block: BlockIndexInfo::Edge(BranchEdge {
                        opcode: instruction.get_opcode(),
                        block_index: if let Some(jump_index) = jump_instruction {
                            if block_map.contains_key(&(jump_index as usize)) {
                                block_map[&(jump_index as usize)].clone()
                            } else {
                                block_queue.push_front(jump_index as usize);

                                BlockIndex::Index(curr_block_index + 1)
                            }
                        } else {
                            BlockIndex::InvalidIndex(
                                instructions
                                    .get_full_arg(index)
                                    .expect("Index is within bounds")
                                    as usize,
                            )
                        },
                    }),
                    default_block: if let Some(next_index) = next_instruction {
                        if block_map.contains_key(&next_index) {
                            BlockIndexInfo::Edge(BranchEdge {
                                opcode: instruction.get_opcode(),
                                block_index: block_map[&next_index].clone(),
                            })
                        } else {
                            block_queue.push_front(next_index);

                            BlockIndexInfo::Edge(BranchEdge {
                                opcode: instruction.get_opcode(),
                                block_index: BlockIndex::Index(
                                    curr_block_index
                                    + 1
                                    // If branch block also exists add another 1
                                    + if let Some(jump_index) = jump_instruction
                                        && !block_map.contains_key(&(jump_index as usize))
                                    {
                                        1
                                    } else {
                                        0
                                    },
                                ),
                            })
                        }
                    } else {
                        BlockIndexInfo::NoIndex
                    },
                });

                break ExitReason::DoesJump;
            }

            curr_block.push(instruction.clone());

            if instruction.stops_execution() {
                blocks.push(Block {
                    instructions: curr_block,
                    branch_block: BlockIndexInfo::NoIndex,
                    default_block: BlockIndexInfo::NoIndex,
                });

                break ExitReason::StopsExecution;
            }

            if index + 1 < instructions.len() {
                index += 1;
            } else {
                blocks.push(Block {
                    instructions: curr_block,
                    branch_block: BlockIndexInfo::NoIndex,
                    default_block: BlockIndexInfo::NoIndex,
                });

                break ExitReason::StopsExecution;
            }
        };

        match exit_reason {
            ExitReason::StopsExecution | ExitReason::DoesJump => {
                block_map.insert(start_index, BlockIndex::Index(curr_block_index));

                curr_block_index += 1;
            }
            ExitReason::IsJumpTarget => {
                curr_block_index += 1;
            }
            _ => {}
        }
    }

    let mut cfg = ControlFlowGraph::<I> {
        start_index: if !blocks.is_empty() {
            BlockIndexInfo::Fallthrough(BlockIndex::Index(0))
        } else {
            BlockIndexInfo::NoIndex
        },

        blocks,
    };

    fix_extended_args(&mut cfg, &block_indexes_to_fix);

    cfg
}

// Convert a cfg that consists of simple instructions to a cfg where the extended args are resolved.
pub fn simple_cfg_to_ext_cfg<SimpleI, ExtI, ExtInstructions>(
    simple_cfg: &ControlFlowGraph<SimpleI>,
) -> Result<ControlFlowGraph<ExtI>, Error>
where
    SimpleI: GenericInstruction<OpargType = u8>,
    ExtI: GenericInstruction<OpargType = u32, Opcode = SimpleI::Opcode>,
    ExtInstructions: ExtInstructionAccess<SimpleI, ExtI>,
{
    let mut blocks = vec![];

    for block in &simple_cfg.blocks {
        let ext_instructions = ExtInstructions::from_instructions(&block.instructions)?.to_vec();

        blocks.push(Block {
            instructions: ext_instructions,
            branch_block: block.branch_block.clone(),
            default_block: block.default_block.clone(),
        });
    }

    Ok(ControlFlowGraph::<ExtI> {
        blocks,
        start_index: simple_cfg.start_index.clone(),
    })
}

#[cfg(test)]
mod test {
    use std::{collections::HashMap, fmt::Debug};

    use crate::{
        CodeObject,
        cfg::{
            Block, BlockIndex, BlockIndexInfo, BranchEdge, ControlFlowGraph, create_cfg,
            simple_cfg_to_ext_cfg,
        },
        traits::GenericInstruction,
        v311::{
            ext_instructions::{ExtInstruction, ExtInstructions},
            instructions::{Instruction, Instructions},
        },
    };

    #[test]
    fn simple_instructions() {
        let instructions = Instructions::new(vec![
            Instruction::LoadConst(0),
            Instruction::LoadConst(1),
            Instruction::CompareOp(0),
            Instruction::PopJumpForwardIfTrue(2),
            Instruction::LoadConst(2),
            Instruction::ReturnValue(0),
            Instruction::LoadConst(3),
            Instruction::ReturnValue(0),
        ]);

        let cfg = create_cfg(instructions.to_vec());

        println!("{}", cfg.make_dot_graph());

        insta::assert_debug_snapshot!(cfg);
    }

    #[test]
    fn simple_program() {
        // for x in range(10):
        //     if x == 9:
        //         print("yay")
        //     else:
        //         print("nay")

        let program = crate::load_code(&b"\xe3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\xf3\\\x00\x00\x00\x97\x00\x02\x00e\x00d\x00\xa6\x01\x00\x00\xab\x01\x00\x00\x00\x00\x00\x00\x00\x00D\x00]\x1fZ\x01e\x01d\x01k\x02\x00\x00\x00\x00r\x0c\x02\x00e\x02d\x02\xa6\x01\x00\x00\xab\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x8c\x14\x02\x00e\x02d\x03\xa6\x01\x00\x00\xab\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x8c d\x04S\x00)\x05\xe9\n\x00\x00\x00\xe9\t\x00\x00\x00\xda\x03yay\xda\x03nayN)\x03\xda\x05range\xda\x01x\xda\x05print\xa9\x00\xf3\x00\x00\x00\x00z\x08<string>\xfa\x08<module>r\x0b\x00\x00\x00\x01\x00\x00\x00sM\x00\x00\x00\xf0\x03\x01\x01\x01\xe0\t\x0e\x88\x15\x88r\x89\x19\x8c\x19\xf0\x00\x04\x01\x15\xf0\x00\x04\x01\x15\x80A\xd8\x07\x08\x88A\x82v\x80v\xd8\x08\r\x88\x05\x88e\x89\x0c\x8c\x0c\x88\x0c\x88\x0c\xe0\x08\r\x88\x05\x88e\x89\x0c\x8c\x0c\x88\x0c\x88\x0c\xf0\t\x04\x01\x15\xf0\x00\x04\x01\x15r\n\x00\x00\x00"[..], (3, 11).into()).unwrap();

        let instructions = match program {
            CodeObject::V311(code) => code.code,
            _ => unreachable!(),
        };

        dbg!(&instructions);

        let cfg = create_cfg(instructions.to_vec());

        dbg!(&cfg);

        println!("{}", cfg.make_dot_graph());

        insta::assert_debug_snapshot!(cfg);
    }

    #[test]
    fn simple_to_ext_instructions() {
        let instructions = Instructions::new(vec![
            Instruction::ExtendedArg(1),
            Instruction::LoadConst(0),
            Instruction::LoadConst(1),
            Instruction::CompareOp(0),
            Instruction::PopJumpForwardIfTrue(2),
            Instruction::LoadConst(2),
            Instruction::ReturnValue(0),
            Instruction::LoadConst(3),
            Instruction::ReturnValue(0),
        ]);

        let cfg = create_cfg(instructions.to_vec());

        println!("{}", cfg.make_dot_graph());

        let cfg: ControlFlowGraph<ExtInstruction> =
            simple_cfg_to_ext_cfg::<Instruction, ExtInstruction, ExtInstructions>(&cfg).unwrap();

        println!("{}", cfg.make_dot_graph());

        insta::assert_debug_snapshot!(cfg);
    }

    #[test]
    fn simple_to_ext_instructions_ext_on_jump() {
        let instructions = Instructions::new(vec![
            Instruction::LoadConst(0),
            Instruction::LoadConst(1),
            Instruction::CompareOp(0),
            Instruction::ExtendedArg(1),
            Instruction::PopJumpForwardIfTrue(2), // Invalid jump target
            Instruction::LoadConst(2),
            Instruction::ReturnValue(0),
            Instruction::LoadConst(3),
            Instruction::ReturnValue(0),
        ]);

        let cfg = create_cfg(instructions.to_vec());

        println!("{}", cfg.make_dot_graph());

        let cfg: ControlFlowGraph<ExtInstruction> =
            simple_cfg_to_ext_cfg::<Instruction, ExtInstruction, ExtInstructions>(&cfg).unwrap();

        println!("{}", cfg.make_dot_graph());

        insta::assert_debug_snapshot!(cfg);
    }

    #[test]
    fn ext_trick() {
        let instructions = Instructions::new(vec![
            Instruction::LoadConst(0),
            Instruction::PopJumpForwardIfTrue(1),
            Instruction::ExtendedArg(0),
            Instruction::ExtendedArg(0),
            Instruction::StoreName(0),
        ]);

        let cfg = create_cfg(instructions.to_vec());

        println!("{}", cfg.make_dot_graph());

        insta::assert_debug_snapshot!(cfg);
    }

    #[test]
    fn ext_trick_with_jump() {
        let instructions = Instructions::new(vec![
            Instruction::LoadConst(0),
            Instruction::PopJumpForwardIfTrue(1),
            Instruction::ExtendedArg(0),
            Instruction::ExtendedArg(0),
            Instruction::JumpForward(0),
        ]);

        let cfg = create_cfg(instructions.to_vec());

        println!("{}", cfg.make_dot_graph());
    }
}
